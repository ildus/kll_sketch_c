#include <stdint.h>
#include <stdlib.h>
#include "kll_sketch.h"

// 64-bit xorshift multiply rng from http://vigna.di.unimi.it/ftp/papers/xorshift.pdf
static uint64_t xor_shift_mult64(uint64_t x)
{
	x ^= x >> 12; // a
	x ^= x << 25; // b
	x ^= x >> 27; // c
	return x * 2685821657736338717;
}

// coin is a simple struct to let us get random bools and make minimum calls
// to the random number generator.
typedef struct
{
	uint64_t st;
	uint64_t mask;
} coin;

// returns either 0 or 1
static int toss()
{
	int res = 0;
	static coin c = {0, 0};

	if (c.mask == 0)
	{
		if (c.st == 0)
			c.st = rand();

		c.st = xor_shift_mult64(c.st);
		c.mask = 1;
	}

	if ((c.st & c.mask) > 0)
		res = 1;

	c.mask <<= 1;
	return res;
}

void quicksort(KLLSketchCompactor * c)
{
}

void insertion_sort(KLLSketchCompactor * c)
{
}

void kll_sketch_compactor_compact(KLLSketchCompactor * c, KLLSketchCompactor * dst)
{
	if (c->len == 0 || c->len == 1);
	else if (c->len == 2)
	{
		if (c->items[0] > c->items[1])
		{
			double tmp = c->items[0];
			c->items[0] = c->items[1];
			c->items[1] = tmp;
		}
	}
	else if (c->len > 100)
		quicksort(c);
	else
		insertion_sort(c);

	free := cap(dst) - len(dst)
	if free < len(*c)/2 {
		extra := len(*c)/2 - free
		newdst := make([]float64, len(dst), cap(dst)+extra)
		copy(newdst, dst)
		dst = newdst
	}

	// choose either the evens or the odds
	int offs = toss();
	for len(*c) >= 2 {
		l := len(*c) - 2
		dst = append(dst, (*c)[l+offs])
		*c = (*c)[:l]
	}

	return dst
}
